for tc in range(1, int(input()) + 1):
    N, M = map(int ,input().split())
    arr = [0] + list(map(int, input().split()))
    # 1. 돌의 개수와 횟수에 따른 상태를 표현하기 위한 배열을 생성한다.
    dp = [[0] * (M + 1) for _ in range(N + 1)]

    # 2. 행 우선 순회로 시작해서 dp 방식으로 값을 채운다.
    for i in range(1, N + 1):
        for j in range(1, M + 1):
            # 3. i == 1일 때, 최대 갈 곳이 하나 밖에 없으므로 arr[1]로 채운다.
            if i == 1:
                dp[i][j] = arr[i]
            # 4. 그 이후부터, [1칸 전에서 건너는 것, 2칸 전에서 건너는 것]을 고려하여 배열 값을 채운다.
            else:
                dp[i][j] = max(dp[i-1][j-1], dp[i-2][j-1]) + arr[i]

    # 5. 예제에서 6번 또는 7번 돌에서 각각 5번만큼 밟았다면, 6번에서는 5번 밟고 7번을 건너 뛸 수 있으므로
    #    [도착 지점에서 1칸 떨어져있는 돌: 7번] or [도착 지점에서 2칸 떨어져있는 돌: 6번] 두 개의 값 중 최대 값을 출력한다.
    res = max(dp[N-1][M], dp[N][M])
    print('#{} {}'.format(tc, res))
    if tc == 4:
        print(*dp, sep='\n')

# 입력 값
# 4
# 7 5
# 5 4 2 7 1 2 3
# 8 6
# 10 10 1 3 1 5 4 7
# 3 1
# 1 3 1
# 7 4
# 1 10 9 8 4 10 3
# 출력 값
# #1 21
# #2 39
# #3 3